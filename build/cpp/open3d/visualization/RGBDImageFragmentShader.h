// Automatically generated header file for shader.
// See LICENSE.txt for full license statement.

const char * const RGBDImageFragmentShader = 
"#version 330\n"
"\n"
"in vec2 UV;\n"
"uniform sampler2D image_texture;\n"
"\n"
"\n"
"/* built-in option to ensure RGB and D are handled in the same shader,\n"
"   which can be used in 2 passes */\n"
"#define DEPTH_TEXTURE_MODE 0\n"
"#define RGB_TEXTURE_MODE 1\n"
"#define GRAYSCALE_TEXTURE_MODE 2\n"
"uniform int texture_mode;\n"
"\n"
"/* Decides the colormap of the depth image */\n"
"uniform float depth_max;\n"
"out vec4 FragColor;\n"
"\n"
"float Interpolate(float value, float y0, float x0, float y1, float x1) {\n"
"    if (value < x0) return y0;\n"
"    if (value > x1) return y1;\n"
"    return (value - x0) * (y1 - y0) / (x1 - x0) + y0;\n"
"}\n"
"\n"
"float Jet(float value /* already clamped in [0, 1] */) {\n"
"    if (value <= -0.75) {\n"
"        return 0.0;\n"
"    } else if (value <= -0.25) {\n"
"        return Interpolate(value, 0.0, -0.75, 1.0, -0.25);\n"
"    } else if (value <= 0.25) {\n"
"        return 1.0;\n"
"    } else if (value <= 0.75) {\n"
"        return Interpolate(value, 1.0, 0.25, 0.0, 0.75);\n"
"    } else {\n"
"        return 0.0;\n"
"    }\n"
"}\n"
"\n"
"void main() {\n"
"    if (texture_mode == DEPTH_TEXTURE_MODE) {\n"
"        float depth = texture(image_texture, UV).r;\n"
"        depth = clamp(depth, 0, depth_max);\n"
"        depth = depth / depth_max;\n"
"        depth = 2 * depth - 1;\n"
"        FragColor = vec4(Jet(depth - 0.5), Jet(depth), Jet(depth + 0.5), 1);\n"
"    } else if (texture_mode == RGB_TEXTURE_MODE) {\n"
"        FragColor = texture(image_texture, UV);\n"
"    } else if (texture_mode == GRAYSCALE_TEXTURE_MODE) {\n"
"        float scalar = texture(image_texture, UV).r;\n"
"        FragColor = vec4(vec3(scalar), 1);\n"
"    }\n"
"}\n"
;
